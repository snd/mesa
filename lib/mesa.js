// Generated by CoffeeScript 1.10.0
var Mesa, Promise, _, helpers, i, len, mesa, mohair, payload, phase, ref, setQueueProperties,
  slice = [].slice,
  hasProp = {}.hasOwnProperty;

mohair = require('mohair');

Promise = require('bluebird');

_ = require('lodash');

helpers = {};

helpers.schemaAwareEscape = function(string) {
  return string.split('.').map(function(str) {
    return "\"" + str + "\"";
  }).join('.');
};

helpers.defaultMohair = mohair.escape(helpers.schemaAwareEscape).returning('*');

helpers.replacePlaceholders = function(sql) {
  var index;
  index = 1;
  return sql.replace(/\?/g, function() {
    return '$' + index++;
  });
};

helpers.ignoredArgumentWarning = function(receiver) {
  return "you called " + receiver + " with an argument but " + receiver + " ignores all arguments. " + receiver + " returns a promise and maybe you wanted to call that promise instead: " + receiver + ".then(function(result) { ... })";
};

helpers.normalizeLink = function(leftTable, rightTable, immutableLink) {
  var leftTableName, link, rightTableName;
  leftTableName = leftTable.getTable();
  rightTableName = rightTable.getTable();
  link = immutableLink != null ? _.clone(immutableLink) : {};
  if (link.forward == null) {
    link.forward = true;
  }
  if (link.first == null) {
    link.first = false;
  }
  if (link.left == null) {
    if (link.forward) {
      link.left = leftTable.getPrimaryKey();
    } else {
      if (rightTableName == null) {
        throw new Error('default for embed option `thisKey` requires call to .table(name) on this table');
      }
      link.left = rightTableName + '_' + rightTable.getPrimaryKey();
    }
  }
  if (link.right == null) {
    if (link.forward) {
      if (leftTableName == null) {
        throw new Error('default for embed option `otherKey` requires call to .table(name) on other table');
      }
      link.right = leftTableName + '_' + leftTable.getPrimaryKey();
    } else {
      link.right = rightTable.getPrimaryKey();
    }
  }
  if (link.as === true) {
    if (rightTableName == null) {
      throw new Error('default for embed option `as` requires call to .table(name) on other table');
    }
    link.as = rightTableName;
    if (!link.first) {
      link.as += 's';
    }
  }
  return link;
};

helpers.normalizeIncludeArguments = function() {
  var args, lastIndex, leftTable, link, normalized;
  args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
  normalized = [];
  leftTable = null;
  link = null;
  lastIndex = args.length - 1;
  args.forEach(function(arg, index) {
    var rightTable;
    if (helpers.isInstance(arg)) {
      if (leftTable != null) {
        link = link != null ? _.clone(link) : {};
        if (index === lastIndex) {
          if (link.as == null) {
            link.as = true;
          }
        }
        rightTable = arg;
        link = helpers.normalizeLink(leftTable, rightTable, link);
        link.table = rightTable;
        normalized.push(link);
        link = null;
      }
      return leftTable = arg;
    } else {
      return link = arg;
    }
  });
  return normalized;
};

Mesa = function(source) {
  var k, v;
  if (source) {
    for (k in source) {
      if (!hasProp.call(source, k)) continue;
      v = source[k];
      this[k] = v;
    }
  }
  return this;
};

Mesa.prototype = {
  fluent: function(key, value) {
    var next;
    next = new Mesa(this);
    next[key] = value;
    return next;
  },
  call: function() {
    var args, f, result;
    f = arguments[0], args = 2 <= arguments.length ? slice.call(arguments, 1) : [];
    result = f.apply(this, args);
    if (!helpers.isInstance(result)) {
      throw new Error('the function passed to .call() must return a mesa-object');
    }
    return result;
  },
  when: function() {
    var args, condition, fn;
    condition = arguments[0], fn = arguments[1], args = 3 <= arguments.length ? slice.call(arguments, 2) : [];
    if (condition) {
      return this.call.apply(this, [fn].concat(slice.call(args)));
    } else {
      return this;
    }
  },
  each: function() {
    var args, arrayOrObject, callback, fn;
    arrayOrObject = arguments[0], fn = arguments[1], args = 3 <= arguments.length ? slice.call(arguments, 2) : [];
    callback = function(that, value, indexOrKey) {
      var result;
      result = fn.call.apply(fn, [that, value, indexOrKey].concat(slice.call(args)));
      if (!helpers.isInstance(result)) {
        throw new Error('the function passed to .each() must return a mesa-object');
      }
      return result;
    };
    return _.reduce(arrayOrObject, callback, this);
  },
  _returnFirst: false,
  returnFirst: function(arg) {
    if (arg == null) {
      arg = true;
    }
    return this.fluent('_returnFirst', arg);
  },
  debug: function(arg) {
    return this.fluent('_debug', arg);
  },
  _allowed: [],
  allow: function() {
    var columns;
    columns = 1 <= arguments.length ? slice.call(arguments, 0) : [];
    return this.fluent('_allowed', _.flatten(columns));
  },
  _isUnsafe: false,
  unsafe: function(isUnsafe) {
    if (isUnsafe == null) {
      isUnsafe = true;
    }
    return this.fluent('_isUnsafe', isUnsafe);
  },
  pickAllowed: function(record) {
    if (this._isUnsafe) {
      return record;
    }
    if (this._allowed.length === 0) {
      throw new Error(['no columns are allowed.', 'this will make .update() or .insert() fail.', 'call .allow(columns...) with at least one column before .insert() or .update().', 'alternatively call .unsafe() before to disable mass assignment protection altogether.'].join(' '));
    }
    return _.pick(record, this._allowed);
  },
  _mohair: helpers.defaultMohair,
  sql: function(escape) {
    return this._mohair.sql(escape);
  },
  params: function() {
    return this._mohair.params();
  },
  raw: function() {
    var args, ref;
    args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
    return (ref = this._mohair).raw.apply(ref, args);
  },
  table: function(arg) {
    return this.fluent('_mohair', this._mohair.table(arg));
  },
  getTable: function() {
    return this._mohair.getTable();
  },
  from: function() {
    var args, ref;
    args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
    return this.fluent('_mohair', (ref = this._mohair).from.apply(ref, args));
  },
  where: function() {
    var args, ref;
    args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
    return this.fluent('_mohair', (ref = this._mohair).where.apply(ref, args));
  },
  having: function() {
    var args, ref;
    args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
    return this.fluent('_mohair', (ref = this._mohair).having.apply(ref, args));
  },
  join: function() {
    var args, ref;
    args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
    return this.fluent('_mohair', (ref = this._mohair).join.apply(ref, args));
  },
  select: function() {
    var args, ref;
    args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
    return this.fluent('_mohair', (ref = this._mohair).select.apply(ref, args));
  },
  limit: function(arg) {
    return this.fluent('_mohair', this._mohair.limit(arg));
  },
  offset: function(arg) {
    return this.fluent('_mohair', this._mohair.offset(arg));
  },
  order: function(arg) {
    return this.fluent('_mohair', this._mohair.order(arg));
  },
  group: function(arg) {
    return this.fluent('_mohair', this._mohair.group(arg));
  },
  "with": function(arg) {
    return this.fluent('_mohair', this._mohair["with"](arg));
  },
  returning: function() {
    var args, ref;
    args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
    return this.fluent('_mohair', (ref = this._mohair).returning.apply(ref, args));
  },
  distinct: function() {
    var args, ref;
    args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
    return this.fluent('_mohair', (ref = this._mohair).distinct.apply(ref, args));
  },
  "for": function() {
    var args, ref;
    args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
    return this.fluent('_mohair', (ref = this._mohair)["for"].apply(ref, args));
  },
  window: function() {
    var args, ref;
    args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
    return this.fluent('_mohair', (ref = this._mohair).window.apply(ref, args));
  },
  combine: function() {
    var args, ref;
    args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
    return this.fluent('_mohair', (ref = this._mohair).combine.apply(ref, args));
  },
  union: function() {
    var args, ref;
    args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
    return this.fluent('_mohair', (ref = this._mohair).union.apply(ref, args));
  },
  unionAll: function() {
    var args, ref;
    args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
    return this.fluent('_mohair', (ref = this._mohair).unionAll.apply(ref, args));
  },
  intersect: function() {
    var args, ref;
    args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
    return this.fluent('_mohair', (ref = this._mohair).intersect.apply(ref, args));
  },
  intersectAll: function() {
    var args, ref;
    args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
    return this.fluent('_mohair', (ref = this._mohair).intersectAll.apply(ref, args));
  },
  except: function() {
    var args, ref;
    args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
    return this.fluent('_mohair', (ref = this._mohair).except.apply(ref, args));
  },
  exceptAll: function() {
    var args, ref;
    args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
    return this.fluent('_mohair', (ref = this._mohair).exceptAll.apply(ref, args));
  },
  setConnection: function(arg) {
    var typeofArg;
    typeofArg = typeof arg;
    if (!(('function' === typeof arg) || (('object' === typeof arg) && (arg.query != null)))) {
      throw new Error('.setConnection() must be called with either a connection object or a function that takes a callback and calls it with a connection');
    }
    return this.fluent('_connection', arg);
  },
  getConnection: function(arg) {
    var connection, debug, that;
    that = this;
    if (arg != null) {
      throw new Error(helpers.ignoredArgumentWarning('.getConnection()'));
    }
    connection = this._connection;
    debug = this._debug;
    if (connection == null) {
      return Promise.reject(new Error("the method you are calling requires a call to .setConnection() before it"));
    }
    return new Promise(function(resolve, reject) {
      if ('function' === typeof connection) {
        return connection(function(err, result, realDone) {
          var done;
          done = function() {
            if (typeof debug === "function") {
              debug('connection', 'done', {}, {
                connection: connection
              }, that);
            }
            return typeof realDone === "function" ? realDone() : void 0;
          };
          if (err != null) {
            if (typeof done === "function") {
              done();
            }
            return reject(err);
          }
          if (typeof debug === "function") {
            debug('connection', 'fresh', {}, {
              connection: result,
              done: done
            }, that);
          }
          return resolve({
            connection: result,
            done: done
          });
        });
      }
      if (typeof debug === "function") {
        debug('connection', 'reuse', {}, {
          connection: connection
        }, that);
      }
      return resolve({
        connection: connection
      });
    });
  },
  wrapInConnection: function(block) {
    return this.getConnection().then(function(arg1) {
      var connection, done;
      connection = arg1.connection, done = arg1.done;
      return block(connection)["finally"](function() {
        return typeof done === "function" ? done() : void 0;
      });
    });
  },
  query: function(sqlOrFragment, params) {
    var debug, sql, that;
    if (mohair.implementsSqlFragmentInterface(sqlOrFragment)) {
      sql = sqlOrFragment.sql(helpers.schemaAwareEscape);
      if (params != null) {
        throw new Error('query with sql fragment as first arg is not allowed to have a second arg');
      }
      params = sqlOrFragment.params();
    } else {
      sql = sqlOrFragment;
    }
    sql = helpers.replacePlaceholders(sql);
    that = this;
    debug = this._debug;
    return this.wrapInConnection(function(connection) {
      return new Promise(function(resolve, reject) {
        if (typeof debug === "function") {
          debug('query', 'before', {
            sql: sql,
            params: params
          }, {
            connection: connection
          }, that);
        }
        return connection.query(sql, params, function(err, results) {
          if (typeof debug === "function") {
            debug('query', 'after', {
              sql: sql,
              params: params
            }, {
              connection: connection,
              err: err,
              results: results
            }, that);
          }
          if (err != null) {
            return reject(err);
          }
          return resolve(results);
        });
      });
    });
  },
  wrapInTransaction: function(block) {
    var debug, that;
    that = this;
    debug = this._debug;
    return this.wrapInConnection(function(connection) {
      var withConnection;
      withConnection = that.setConnection(connection);
      if (typeof debug === "function") {
        debug('transaction', 'begin', {}, {
          connection: connection,
          block: block
        }, that);
      }
      return withConnection.query('BEGIN;').then(function() {
        return block(connection);
      }).then(function(result) {
        if (typeof debug === "function") {
          debug('transaction', 'commit', {}, {
            connection: connection,
            block: block
          }, that);
        }
        return withConnection.query('COMMIT;').then(function() {
          return result;
        });
      })["catch"](function(error) {
        if (typeof debug === "function") {
          debug('transaction', 'rollback', {
            error: error
          }, {
            connection: connection,
            block: block
          }, that);
        }
        return withConnection.query('ROLLBACK;').then(function() {
          return Promise.reject(error);
        });
      });
    });
  },
  runQueue: function(queue, value) {
    var context, reducer;
    context = this;
    reducer = function(soFar, step) {
      return soFar.then(step.bind(context));
    };
    return queue.reduce(reducer, Promise.resolve(value));
  },
  afterQuery: function(results, options) {
    var debug, rows, that;
    that = this;
    debug = this._debug;
    rows = results.rows;
    if (!rows) {
      return results;
    }
    if (typeof debug === "function") {
      debug('after-query', 'before-queue', {
        rows: rows
      }, options, that);
    }
    return this.runQueue(options.after, rows).map(this.runQueue.bind(this, options.afterEach)).then(function(rows) {
      if (typeof debug === "function") {
        debug('after-query', 'after-queue', {
          rows: rows
        }, options, that);
      }
      if (options.returnFirst) {
        return rows[0];
      } else {
        return rows;
      }
    });
  },
  insert: function() {
    var args, debug, records, returnFirst, that;
    args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
    that = this;
    debug = this._debug;
    records = _.flatten(args);
    if (records.length === 0) {
      throw new Error('no records to insert');
    }
    returnFirst = args.length === 1 && !Array.isArray(args[0]);
    if (typeof debug === "function") {
      debug('insert', 'before-queue', {
        records: records
      }, {}, that);
    }
    return this.runQueue(this._queueBeforeInsert, records).map(this.runQueue.bind(this, this._queueBeforeEachInsert)).then(function(records) {
      if (typeof debug === "function") {
        debug('insert', 'after-queue', {
          records: records
        }, {}, that);
      }
      records.forEach(function(record, index) {
        if (Object.keys(record).length === 0) {
          throw new Error("insert would fail because record at index " + index + " is empty after processing before queue");
        }
      });
      return that.query(that._mohair.insert(records)).then(function(results) {
        return that.afterQuery(results, {
          returnFirst: returnFirst,
          after: that._queueAfterInsert,
          afterEach: that._queueAfterEachInsert
        });
      });
    });
  },
  update: function(update) {
    var debug, that;
    that = this;
    debug = this._debug;
    if (typeof debug === "function") {
      debug('update', 'before-queue', {
        update: update
      }, {}, that);
    }
    return this.runQueue(this._queueBeforeEachUpdate, update).then(function(update) {
      if (typeof debug === "function") {
        debug('update', 'after-queue', {
          update: update
        }, {}, that);
      }
      return that.query(that._mohair.update(update)).then(function(results) {
        return that.afterQuery(results, {
          returnFirst: that._returnFirst,
          after: that._queueAfterUpdate,
          afterEach: that._queueAfterEachUpdate
        });
      });
    });
  },
  "delete": function() {
    var that;
    if (typeof arg !== "undefined" && arg !== null) {
      throw new Error(helpers.ignoredArgumentWarning('.delete()'));
    }
    that = this;
    return that.query(that._mohair["delete"]()).then(function(results) {
      return that.afterQuery(results, {
        returnFirst: that._returnFirst,
        after: that._queueAfterDelete,
        afterEach: that._queueAfterEachDelete
      });
    });
  },
  find: function(arg) {
    var that;
    if (arg != null) {
      throw new Error(helpers.ignoredArgumentWarning('.find()'));
    }
    that = this;
    return that.query(this).then(function(results) {
      return that.afterQuery(results, {
        returnFirst: that._returnFirst,
        after: that._queueAfterSelect,
        afterEach: that._queueAfterEachSelect
      });
    });
  },
  first: function(arg) {
    if (arg != null) {
      throw new Error(helpers.ignoredArgumentWarning('.first()'));
    }
    return this.limit(1).returnFirst().find();
  },
  exists: function(arg) {
    if (arg != null) {
      throw new Error(helpers.ignoredArgumentWarning('.exists()'));
    }
    return this.query(this._mohair.limit(1)).then(function(results) {
      return (results.rows != null) && results.rows.length !== 0;
    });
  },
  _primaryKey: 'id',
  primaryKey: function(arg) {
    return this.fluent('_primaryKey', arg);
  },
  getPrimaryKey: function() {
    return this._primaryKey;
  },
  baseEmbed: function(originalRecords, includes) {
    var groupedByFirst, prevRecords, reducer;
    groupedByFirst = null;
    prevRecords = originalRecords;
    reducer = function(soFar, include) {
      return soFar.then(function() {
        var condition;
        condition = {};
        condition[include.right] = _.map(prevRecords, include.left);
        return include.table.where(condition).find().then(function(nextRecords) {
          var groupedByCurrent;
          groupedByCurrent = _.groupBy(nextRecords, include.right);
          groupedByFirst = groupedByFirst == null ? groupedByCurrent : _.mapValues(groupedByFirst, function(records) {
            return _.reduce(records, (function(acc, record) {
              records = groupedByCurrent[record[include.left]];
              if (records != null) {
                return acc.concat(records);
              } else {
                return acc;
              }
            }), []);
          });
          if (include.as != null) {
            originalRecords.forEach(function(record) {
              var group;
              group = groupedByFirst[record[includes[0].left]] || [];
              if (include.first) {
                if (group[0] != null) {
                  return record[include.as] = group[0];
                }
              } else {
                return record[include.as] = group;
              }
            });
          }
          return prevRecords = nextRecords;
        });
      });
    };
    return includes.reduce(reducer, Promise.resolve()).then(function() {
      return originalRecords;
    });
  },
  embed: function() {
    var args, records;
    records = arguments[0], args = 2 <= arguments.length ? slice.call(arguments, 1) : [];
    if (records.length === 0) {
      return records;
    }
    return this.baseEmbed(records, helpers.normalizeIncludeArguments.apply(helpers, [this].concat(slice.call(args))));
  },
  include: function() {
    var args;
    args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
    return this.queueAfter(_.partialRight.apply(_, [this.embed].concat(slice.call(args))));
  }
};

payload = function() {
  var args, f;
  f = arguments[0], args = 2 <= arguments.length ? slice.call(arguments, 1) : [];
  if (args.length === 0) {
    return f;
  } else {
    return _.partialRight.apply(_, [f].concat(slice.call(args)));
  }
};

setQueueProperties = function(object, suffix) {
  var dataPropertyName, setterPropertyName;
  setterPropertyName = 'queue' + suffix;
  dataPropertyName = '_' + setterPropertyName;
  object[dataPropertyName] = [];
  return object[setterPropertyName] = function() {
    var args;
    args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
    return this.fluent(dataPropertyName, this[dataPropertyName].concat([payload.apply(null, args)]));
  };
};

setQueueProperties(Mesa.prototype, 'BeforeInsert');

setQueueProperties(Mesa.prototype, 'BeforeEachInsert');

setQueueProperties(Mesa.prototype, 'BeforeEachUpdate');

ref = ['Select', 'Insert', 'Update', 'Delete'];
for (i = 0, len = ref.length; i < len; i++) {
  phase = ref[i];
  setQueueProperties(Mesa.prototype, 'After' + phase);
  setQueueProperties(Mesa.prototype, 'AfterEach' + phase);
}

Mesa.prototype.queueBeforeEach = function() {
  var args, object;
  args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
  object = new Mesa(this);
  ['Insert', 'Update'].forEach(function(phase) {
    var propertyName;
    propertyName = '_queueBeforeEach' + phase;
    return object[propertyName] = object[propertyName].concat([payload.apply(null, args)]);
  });
  return object;
};

Mesa.prototype.queueAfter = function() {
  var args, object;
  args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
  object = new Mesa(this);
  ['Select', 'Insert', 'Update', 'Delete'].forEach(function(phase) {
    var propertyName;
    propertyName = '_queueAfter' + phase;
    return object[propertyName] = object[propertyName].concat([payload.apply(null, args)]);
  });
  return object;
};

Mesa.prototype.queueAfterEach = function() {
  var args, object;
  args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
  object = new Mesa(this);
  ['Select', 'Insert', 'Update', 'Delete'].forEach(function(phase) {
    var propertyName;
    propertyName = '_queueAfterEach' + phase;
    return object[propertyName] = object[propertyName].concat([payload.apply(null, args)]);
  });
  return object;
};

Mesa.prototype.isInstance = helpers.isInstance = function(object) {
  return object instanceof Mesa;
};

Mesa.prototype.helpers = helpers;

mesa = new Mesa;

module.exports = mesa.queueBeforeEach(mesa.pickAllowed);
